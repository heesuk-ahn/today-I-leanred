# 재귀 함수 전반적인 정리

* __재귀 함수는 자기 자신을 호출하는 함수이다.__

```
  void func(...) {
    return func(...)
  }
```

* 위와 같이 선언한다면, stack over flow가 발생할 것이다. 물론, 꼬리재귀 최적화가 지원된다면,
무한 반복문에 빠지게 될 것이다.
* 만약, 그렇지 않을 경우 __stack over flow__ 가 발생하는데 왜그럴까?

```
n - func()
.
.
.
3 - func()
2 - func()
1 - func()
```

* 당연한 결과다. 함수가 호출 될 때마다 `스택 프레임`이 생성되며, `스택 프레임`은 공짜가 아니다.
* 파라미터, 지역변수, 돌아갈 주소지 등이 필요하며, 스택에 `스택 프레임`이 쌓이게 된다.
* 그렇다면 recursion은 항상 무한 루프에 빠지는 것일까?
* 그런 것은 아니다. __함수가 언젠가는 꼭 종료될 것이라는 조건, 또는 상황이 된다면 재귀를 빠져나올 수 있다__
* 이러한 __탈출 조건__ 을 `base case` 라고 한다.

```
public static void func(int k) {
  if(k<=0) {
    return;   //`base case` 존재
  } else {
    func(k-1);    //`recursive case` 문제를 좀 더 작게 쪼게는 것
  }
}
```

```
func(4) <- func(3) 반환
  func(3) <- func(2) 반환
    func(2) <- func(1) 반환
      func(1) <- func(0) 반환
        func(O) //종료 및 반환 시작
```

* 위의 call stack에서 `recursive`가 문제를 쪼개고, `base case`에서 탈출하여 반환이 시작되는 것이
기본적인 `TOP-DOWN` 방식의 재귀이다.

* 위와 같이 `TOP-DOWN` 방식이 가능한 이유는 함수가 호출 될 때, 스택에 저장되는 `Stack Frame`
덕분이다.

* `Stack Frame`은 `지역 변수`, `매개 변수`, `반환 주소 값` 을 지니고 있다.
* 고로 재귀로 불려진 함수는 작업이 끝난 후, 반환 주소 값을 이용하여 자신이 호출된 Stack Frame으로 반환이 시작되는 것이다.

## 재귀의 설계 3가지 컴포넌트

  * 1) `Base Case`
    * 항상 탈출 조건은 필요하다. 언젠가는 특정 상수로 수렴하거나 더이상 실행될 코드가 없어야 한다.

  * 2) `Recursive Case`
    * 문제가 Base Case가 아니라면, 좀 더 작게 문제를 쪼개서 자기 자신을 호출해야한다.

  * 3) `Explicit parameter`
    * 재귀 함수에서 파라미터는 특별하다. 반복되는 재귀 안에서 사용될 수 있는 '상태'를 지니고 있기 때문이다.
    * 재귀 함수에서 파라미터를 설계 할 때는 필요한 파라미터를 명시적으로 선언해주어야 한다.
