# 재귀 알고리즘은 왜 필요할까?

```
* 1) 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때.
* 2) 변수 사용을 줄여준다.
```

* 변수 사용을 줄여준다는 것은 메모리 관련된 얘기가 아니라, mutable state를 제거하여 프로그램 오류가
일어날 가능성을 줄여준다는 것이다.
* 함수형 프로그래밍에서 함수를 일급 객체로 취급하여 함수를 인자로 전달 및 반환함으로써, mutable state를
제거하는 것과 같다.

## 그렇다면 왜 재귀를 자주 쓰지 않을까?

* 재귀함수는 장점이 큰 만큼 단점도 크다.
  * __메모리를 많이 차지하며 성능이 반복문에 비해 느리다__  
  * 함수를 호출 시 함수의 매개변수, 지역변수, 리턴 값, 그리고 함수 종료 후 돌아가는 위치가 스택 메모리에
  저장된다.
  * 재귀 함수를 쓰게 되면, 함수를 `반복적`으로 호출하면서 이런 `스택 프레임`을 반복적으로 생성하게 되면서
  스택 메모리가 커지게 되고, 호출하는 횟수가 많아지면 결국 `스택오버플로우`가 발생할 수 있다.
  * 또한, 스택 프레임을 구성하고 해제하는 과정에서 반복문보다 오버헤드가 들어 성능도 느려진다.
* 원점으로 돌아가서, 이런 문제를 해결하기 위해 컴파일 시간에 최적화가 가능한 `꼬리 재귀`가 있다.
    * 1) 프로그래머가 재귀 함수를 꼬리 재귀 방식으로 개발한다.
    * 2) 컴파일러가 꼬리 재귀 최적화를 지원해야한다.
* 컴파일러가 꼬리 재귀 최적화를 지원하지않으면, 꼬리 재귀함수로 개발한다 하더라도 성능 및 메모리 이점을 얻을 수 없다.
* 코드적으로 보면 꼬리 재귀는 다음과 같은 형태를 가진다.

```
 int recursive(int n) {
    if(n == 1) return 1;
    return n + recursive(n-1);
    //최종 반환시, 자기 자신만을 호출하는 것이 `꼬리 재귀`인데 `n` 이 더해지기 때문에 꼬리 재귀가 아니다.
 }

 int tailRecursive(int n, int acc) {
   if (n==1) return acc;
   return tailRecursive(n-1, acc + n);
   //최종 반환식이 자기 자신을 호출하기 때문에, 꼬리재귀이다.
 }
```

## 그렇다면 왜 `최종 반환식`이 `자기 자신`일 경우 `꼬리 재귀`가 되면서 최적화가 될 수 있을까?

* `스택 프레임` 입장에서 생각하면 편하다. 스택 프레임 입장에서는 항상 자기 자신만을 반환하기 때문에
새로운 `스택 프레임`을 생성할 필요가 없다. 즉, 스택 프레임 입장에서 변화하는 값 (매개 변수) 만 변경하면
되기 때문에, __자기 자신을 반환하는 재귀 함수 구조의 경우는 꼬리 재귀라고 하는 것이다.__

### 참고
* [재귀 함수를 쓰는 이유] https://medium.com/sjk5766/%EC%9E%AC%EA%B7%80%ED%95%A8%EC%88%98%EB%A5%BC-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0-ed7c37d01ee0
