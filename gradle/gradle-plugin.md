* `Gradle`과 플러그인
  * `Gradle`에서 플러그인 기능을 빼면 그다지 특별한 것이 없다.
  * 우리가 기대하는 Java 코드를 컴파일하는 등의 일은 모두 플러그인의 힘이다.
  * 플러그인은 `Gradle`의 중요 객체 또는 다른 플러그인의 객체를 확장하여 사융할 수 있도록 해줄 뿐 아니라
   `JavaCompile`처럼 `Task`나 `SourceSet`처럼 도메인 객체와 `Java`의 소스는 `src/main/java`이라는 컨벤션을 포함시킨다.
  * 플러그인이 하는 일을 좀 더 자세히 살펴보자.
      * 플러그인의 역할은 `Gradle`의 `buildscript` 에 **확장된 기능** 을 부여하는 것이다. 좀 더 구체적으로 플러그인의 역할은 다음과 같다.
          1. `Gradle`의 모델을 확장한다. (예를 들어서 새롭게 구성 가능한 DSL 요소를 추가한다.)
          2. `Gradle`의 컨벤션에 맞춰 프로젝트를 구성한다. (`Task`를 추가하거나, 중요한 기본 설정을 셋팅)
          3. 특수한 설정을 추가한다.
      * 플러그인을 적용하는 것과 직접 `buildscript`를 구성하는 것의 차이가 있을까? 플러그인을 구성하는 것의 이점이 있다.
          1. 재사용성의 증가 (중복 코드 제거, 여러 프로젝트에서 재활용 가능)
          2. 모듈화를 통한 응집도
          3. 절차적인 로직을 캡슐화하여 가능한 `buildscript`를 선언적으로 작성하게 함.
      * 이러한 플러그인을 활용하여 원하는 `buildscript`를 빠르고 쉽게 작성할 수 있다. 이를테면, 'java' 플러그인을 사용하면 java compile을 위한
       다양한 task 들이 함께 `buildscript`에 import 된다.
  * 플러그인의 종류
      * script 플러그인 : `buildscript`를 추가로 설정하는 외부 빌드스크립트라 생각하자.
      * binary 플러그인 : `Plugin` 인터페이스를 구현하는 구상 클래스
      * 처음에는 작성이 용이한 script 플러그인으로 활용하다 재사용성이 증가하고 필요한 경우 Binary 플러그인으로 전환하면 된다.
  * 플러그인 사용
      * 플러그인을 사용할 때, `Gradle`은 두가지 단계를 필요로 한다.
          1. 플러그인을 확정(resolve)하는 단계
          2. 플러그인을 대상(보통은 `Project`)에 적용하는 단계
  * 플러그인의 확정 단계
      * 이 단계에서는 사용할 플러그인을 가지는 정확한 버전의 jar 파일을 찾아 스크립트의 클래스패스에 포함시킨다.
          * 당연한 얘기이지만, `buildscript`도 하나의 프로그램이기 때문에 외부 라이브러리를 추가할 수 있다.
      * `script 플러그인`의 경우 그 자체로 외부 파일의 경로나 URL이 주어지기 때문에 확정과정의 어려움이 없다.
      * `Gradle`이 제공하는 `Binary 플러그인`이 있는데 이를 `Core 플러그인` 이라 한다.
      * 이 플러그인들은 `Gradle`의 배포버전에 함께 포함되기 때문에 자동으로 확정된다.
  * 플러그인의 적용 단계
      * 플러그인을 적용한다는 것은 `Project`를 강화시킬 플러그인의 `Plugin.apply(T)`를 실행하는 것이라 보면 된다.
      * 다행스럽게도(?) 플러그인의 적용은 멱등성(idempotent)하기 때문에 안전하게 여러번 적용해도 부수효과가 없다.
  * 일반적인 사용법
      * 특별한 경우가 아니면 `확정`과 함께 `적용`을 통해 플러그인을 사용하는 것이 보편적이다.
      * `플러그인 DSL`로 플러그인을 사용하는 것을 권장한다. 바로 아래에서 `플러그인 DSL` 방식을 살펴보자.
  * 플러그인 DSL 방식
      * 플러그인의 의존성을 표현하는 명확하고도 간편한 방식이다.
      * core 플러그인과 커뮤니티 플러그인에 쉽게 접근할 수 있는 `플러그인 포털 (gradle의 repository 라고 생각하면 편하다)`에 접근한다.
      ```
         plugins {
           java // Core Plugin, short name으로 충분
           id("com.jfrog.bintray") version "0.4.1" // FQN으로 id 명시
         }
       ```
      * 플러그인 DSL은 단순히 간편하게 플러그인을 **확정/적용 하는 것이 전부가 아니다.**
           1. 플러그인 클래스의 재사용 및 로딩 최적화 (어떻게 최적화를 할까.)
          2. 다른 플러그인이 다른 의존 버전을 사용하는 것 허용 (예시가 필요하다.)
          3. 에디터 보조기능을 위해 `buildscript`의 잠재적인 속성이나 값에 대한 정보를 제공 (예시가 필요하다.)
       * 구문의 강제화
          * 멱등성을 지키기 위해서 `plugins {}`은 모호한 임의의 코드를 허용하지 않고 엄격한 구문을 갖고 있다.
          ```
             plugins {
               'plugin id' ---- (1)
               id ''
             }         
           ```  
