# Extract Class

## Motivation

* `Class` 는 분명하게 추상화 되어야 하고, 몇 가지 명확한 책임을 가져야 한다는 지침을 들어봤을 것이다.
* 실제로 `Class` 는 __점점 커진다.__
* 어떤 동작을 추가할 떄도 있고, 약간의 데이터를 추가할 때도 있다.
* __우리는 별도의 클래스로 만들 만한 가치가 없다고 느끼는 책임을 기존 클래스에 추가한다.__
* 클래스는 `많은 클래스`와 `데이터`를 가지고 있고, 너무 커서 쉽게 이해 할 수도 없게 된다.
* 이러한 `클래스`를 우리는 분리할 방법에 대해서 고민을 해보아야 한다.
* 데이터의 `부분 집합`과 메소드의 `부분 집합`이 같이 몰려다니는 것은 별도의 클래스로 분할 수 있다는
좋은 신호이다.
* 같이 변하거나 특별히 서로에게 의존적인 `데이터의 부분 집합` 또한 별도의 클래스로 분리할 수 있다는 좋은 신호이다
* 만약 `일부 데이터`나 `메소드`를 제거한다면 다른 필드나 메소드가 `의미없는 것`이 될지를 자신에게 물어보는 것은 `편리한 테스트 방법`이다.

## 절차

* 1) 클래스는 `단일 책임 원칙` 을 기반으로 `책임` 을 어떻게 나눌지 결정해야 한다.
* 2) 분리된 책임을 떠맡을 `새로운 클래스`를 만든다.
  * 책임을 분리한 후 이전 `클래스의 책임`이 `이름`과 더 이상 맞지 않는다면, __이전 클래스의 이름을 변경한다.__
* 3) `이전 클래스`에서 `새로 만든 클래스`에 대한 `참조`를 만든다.  
* 4) 옮기고가 하는 각각의 필드에 대해 Move Field를 사용한다
* 5) 각각의 필드를 옮길 때마다 컴파일, 테스트를 한다.
* 6) `Move Method`를 사용해서 `이전 클래스`에서 `새로 만든 클래스`로 메소드를 옮긴다.
 저수준 메소드(호출하기 보다는 호출되는 메소드)부터 시작해서 점점 고수준의 메소드에 적용한다.
* 각각의 메소드를 옮길 때마다 컴파일, 테스트 한다.
* 각 클래스를 검토하고, 인터페이스를 줄인다.
* 새로운 클래스를 공개할지 결정한다. 새로운 클래스를 공개하기로 결정했다면, 참조 객체로 드러낼지 또는 불변성 값 객체(immutable value object)로 드러낼지를 결정한다.
