# 코드 가독성 - 도입과 원칙

## 코드 가독성을 높이기 위한 아이디어

* 팀이 커지고 프로젝트가 커지게 되면 코드의 양도 점점 커지기 마련이다.
* 이런 거대한 프로젝트는 `코드 가독성 유지`와 `기술 부채의 지속적인 상환` 자체를 확장 가능한 상태로 만들어야 한다.
* 즉, 개발에 관여하는 멤버 모두가 가독성과 기술 부채를 신경 쓸 필요가 있다.
* 가독성이 좋은 코드를 짜는 것은 어려운 일. 그렇기 때문에 __어떤 코드가 잘 읽히는지에 관한 지식과 효율적으로 프로그램의 구조를 재구성하는 기술__ 이 필요하다.

## 1장. 도입과 원칙
* 코드는 왜 가독성이 중요한가?
  * Your 5 minutes could save 1 hour for others
* 가독성에 대해서 중시해야 할지 말지에 관한 손익 분기점
  * `코드를 읽거나 다른 사람에게 코드를 해설하는 시간` vs `코드를 작성하는 시간 중 어느쪽이 더 오래 걸리는 지가 하나의 기준`
  * 여기서 주의 할 점은 코드를 작성하는 도중에 `다른 코드를 참조하는 시간`이나 `코드 리뷰`를 하는 시간도 `코드를 읽는 시간`에 포함해야 한다는 것
* 프로그래밍 원칙
  * The Boy Scout rule
    * 이 세계에 당신이 발견한 것 보다 더 나은 작은 변화를 남기는 것을 시도하라. - Robert Baden-Powell
    * 보이스카우트 운동의 창시자의 격언을 Robert C. Martin 이 소프트웨어 개발에 적용한 것
    * '코드를 변경할 때는 리팩토링 할 수 있는 부분은 리팩토링 하면서 더 깔끔하게 만들자’ 라는 것.
      * 예) 변경하는 김에 알기 쉬운 이름으로 리팩토링
      * 예) 변경하는 김에 테스트를 추가
      * 예) 변경하는 김에 사용하지 않는 코드삭제
    * 즉, ‘지저분한 코드를 더 지저분하게 만들지 말라’.
    * 이는 ‘깨진 유리창’ 이론처럼 지저분한 코드에는 더 지저분한 코드들이 생산될 수 있음.
    * 그렇기에 , ‘깨진 유리창’을 보고 변경을 하게 될 때는 겸사겸사 ‘청소, 정리정돈’도 함께 행하는 것.
    * 거대한 switch 문에 새로운 케이스를 추가하는 것은 이 원칙에 위반
    * 새로운 케이스를 추가하기 전에 전략 패턴 (strategy pattern)을 사용해서 리팩토링이 필요하다.
  * YAGN
    * `Y`ou `A`ren’t `G`onna `N`eed `I`t  = Implement it only when you need itt
    * 이 원칙은 `기능과 코드는 필요할 때 구현해야 하며, 앞으로 필요해질 것 같다는 이유로 구현해서는 안된다고 주장`한다.
    * 현재 필요하지 않은 코드의 예로는
      * 유틸리티 함수
      * 구현이 하나 이하인 추상화 레이어
      * 고정 값 밖에 주어지지 않는 dummy argument 등
    * 미래에 대비한 기능과 코드는 실제로 사용하지 않을 가능성이 높을 뿐 아니라, 코드 변경이 필요할 때 장애가 될 수 있다.
    * 이러한 점에서 발생할 변경에 대해 유연하게 대처하기 위해서는 쓸데없는 기능 구현을 피하고 설계를 __단순화__ 하는 것이 중요하다.
    * 다만, 이 원칙은 `코드 변경이 쉽다`는 것을 전제로 하고 있다.
    * 변경이 어려운 경우에는 이 원칙은 예외로 처리되어야 한다. 이러한 경우에는 __어떻게 사용될지 고려해서 설계하고 구현해야 한다__
      * 예 1) 마이그레이션이 어려운 데이터베이스 스키마
      * 예 2) 외부에 공개하는 API 라이브러리
  * KISS (Keep It Simple Stupid)
    * 가독성을 위해 코드의 설계, 구현 기법은 단순화되어야 한다.
    * `개발의 목적` 을 위해 `수단`을 도입하여야 하는데, 그 반대로 `수단` 자체가 목적이 되어서는 안된다.
    * 과유불급! 과도한 패러다임, 원칙, 디자인 패턴, 설계 기법 자체가 목적이 되어버리면 오히려 가독성과 견고함이 떨어질 수 있다.
    * __아름다운 코드는 항상 읽기 좋은 것은 아니다.__
  * Single responsibility principle
    * 오브젝트 지향을 위한 SOLID 원칙 가운데 하나
    * 하나의 `클래스`는 하나의 이유로만 변경되어야 한다.
    * 즉, 클래스는 하나의 단일 목표를 위해 만들어져야 한다. 그러기 위해 `책임`과 `관심`의 범위는 하나로 좁혀져야 한다.
    * 이는 하나의 펑션에도 적용된다. 하나의 목적을 위해 만들어진 것은 견고하며, 작고, 모듈화되어 있어서 가독성과 이해하기가 쉽다.
  * Premature optimization is the root of all evil
    * __조기 최적화는 모든 악의 근원이다.__
    * 효과가 작은 최적화는 하면 안되는 것을 주장하는 원칙
    * 코드가 오히려 복잡해 지는 최적화는 효과가 클 때만 해야한다.
    * 다만, 코드의 가독성이 좋아지는 최적화는 이 원칙에 포함된다고 할 수 없다.
    * 예를 들어, `ArrayList` 의 요소를 반복문으로 검색하는 코드를 `HashMap`으로 치환하면, 메모리 사용량은 늘어날지 모르지만, 계산량이 줄어들고 코드도 간결해진다.

## 결론

* 개발은 혼자하는 것이 아니기 때문에, 코딩을 할 때는 내가 이해하기 쉬운 코드보다 팀원이 이해하기 쉽도록 짜는 것이 장기적으로 보아 이득이다.
* 왜냐면 코드는 항상 누군가에 의해 유지보수되어야 하기 때문이다.
* 클린 코드를 짜기 위한 나의 노력 5분은 다른 개발자의 1시간을 아껴줄 수 있다.

### 참고
* https://engineering.linecorp.com/ko/blog/code-readability-vol1/ [코드 가독성에 대해 - 1. 도입과 원칙]
